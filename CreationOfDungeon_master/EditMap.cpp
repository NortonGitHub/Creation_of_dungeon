#include "EditMap.h"
#include "FunctionTransScene.h"
#include "PanelBase.h"

#include "PanelAffectObjects.h"
#include "PanelDisplayer.h"
#include "PanelSceneTransition.h"
#include "PanelSettingObject.h"

#include "cd_666s/Utility/CSVReader.h"
#include "cd_666s/Resources/AllResourceManager.h"

#include "PanelObjectManager.h"

#include <typeinfo>
#include <sstream>

#include <assert.h>

EditMap::EditMap(std::string _stage_num)
    : stage_num(_stage_num), NPOS(std::string::npos)
{
    _functions.reserve(20);
    //panels.reserve(30);
    class_name = "editmap";

    Init();
}


EditMap::~EditMap()
{
    _functions.clear();

    PANEL_MGR->Clear();

    PANEL_MGR->Refresh();

#if 1
    std::string pass = RESOURCE_TABLE->GetFolderPath();
    std::string str = "csv/Stagedata/template.csv";
    pass += str;
    std::remove(pass.c_str());
#endif
}

SceneBase * EditMap::Update(UIManager _ui)
{
    //std function に変更する？
    _functions.resize(0);

    //NOTE:
    //各個別UIに種類別の情報を格納し、
    //またほかのUIからの戻り値や情報の変化によってその値を返したり変更したりする
    //仕組みを考案する必要がある

    std::string _ui_name;

#if 1
    /*試しコード*/
    /*NOTE*/
    /*
    PanelBaseには、そのパネルの名前、座標、変数が格納されている
    変数は子クラスごとに異なるので注意
    */
    //std::vector<PanelBase> panels; //試験コード用

    /*
    別のオブジェクトへのアクセスが必要になった際に
    対象となるオブジェクトを格納する
    配列 ならびに 簡易関数
    */
    /*multimap キー:カテゴリ名, 値:対象のクラス型オブジェクト*/
    std::multimap<std::string, PanelBase> _targets;
    auto SetClassType = [&] {
        _targets.clear();
    };

    auto scene = PanelFunction();



#endif

#if 0
    _ui.Update(_functions, _ui_name);
    for (auto f : _functions) {
        if (f.find("CHANGE_LIST") != std::string::npos) {
            //_se.Play();
        }
        else if (f.find("SHOW") != std::string::npos) {
            //_se.Play();
        }
        else if (f.find("MOVE") != std::string::npos) {
            //_se.Play();
        }
        else if (f.find("SELECT_OBJECT") != std::string::npos) {
            _dungeon->PickupObject();
            //_se.Play();
        }
    }
#endif

    for (auto p : PANEL_MGR->_objects) {
        if (p != nullptr)
            p->Update();
    }

    //_dungeon->Update();

    return scene;
}

void EditMap::Draw()
{
    //_dungeon->Draw();

    for (auto p : PANEL_MGR->_objects) {
        if (p != nullptr)
            p->Draw();
    }

    PANEL_MGR->Refresh();

}

void EditMap::Init()
{
    //パネルの読み込み
    CSVReader reader;
    std::vector<std::string> panels_str;
    std::string filename = "csv/Panel/";
    filename += class_name + ".csv";
    reader.Read(RESOURCE_TABLE->GetFolderPath() + filename, panels_str, 1);

    DebugOutputFile();

    //ここにPANEL_MGR追加処理を
    int elem_count = 0;
    std::vector<std::string> panel_temp;


    /******オブジェクト設置パネル ファイル読み込み　開始*******/
    const std::string panel_category[3] = { "BLOCK","MONSTER","TRAP" };

    for (auto panel_c : panel_category) {
        std::string fileName = "csv/Edit/";
        fileName += panel_c + ".csv";
        std::vector<std::string> _array;

        reader.Read(RESOURCE_TABLE->GetFolderPath() + fileName, _array, 0);

        int i = 0;
        for (auto f : _array) {
            std::string filename = panel_c + "/" + f;

            Vector2D _pos = Vector2D(std::stoi(panels_str[i]), std::stoi(panels_str[i + 1]));
            //選択用のパネルの情報を初期化代入
            auto panelTemp = std::make_shared<PanelSettingObject>(PanelContent(_pos, filename, ""));

            //オブジェクト設置パネルのすべてのカテゴリ分をmap配列に挿入
            _allSettingPanel.insert(std::make_pair(panel_c, panelTemp));
            i += 5;
        }
    }
    /******オブジェクト設置パネル ファイル読み込み　終了*******/

    auto& panel_obj = PANEL_MGR->_objects;

    for (std::string p : panels_str) {
        if (p != "") {
            panel_temp.push_back(p);
            if (elem_count >= 4) {

                try {
                    std::shared_ptr<PanelBase> temp;

                    auto temp2 = PanelContent(Vector2D(std::stoi(panel_temp[0]), std::stoi(panel_temp[1])), panel_temp[2], panel_temp[4]);

                    SetPanelInstance(panel_temp[3], temp, temp2);

                    panel_obj.push_back(temp);
                    panel_obj.back()->Init(temp2);

                    //panel_cont_temp.push_back(PanelContent(
                    //Vector2D(std::stoi(panel_temp[0]), std::stoi(panel_temp[1])), panel_temp[2], panel_temp[4]));
                }
                catch (std::out_of_range&) {
                    assert("Cannot push_back panel elem");
                }
                panel_temp.clear();
                elem_count = 0;
            }
            else {
                elem_count++;
            }
        }
    }

    PanelAffectObjectsFunction("MONSTER");

    std::string file_name = (IsFirstWave() ? "template" : "map" + stage_num);

    for (auto p : PANEL_MGR->_objects) {
        if (p == nullptr)
            continue;
        p->DrawDebugPrint();
    }

    PANEL_MGR->Refresh();

    _dungeon = std::make_shared<MakeDungeon>(stage_num);
    _dungeon->Init(file_name);
}

bool EditMap::IsFirstWave()
{
    CSVReader reader;

    std::string filePass = "csv/StageData/";
    std::string fileName = filePass + "template.csv";
    std::vector<std::string> stage_data;

    reader.Read(RESOURCE_TABLE->GetFolderPath() + fileName, stage_data, 0);
    auto b = stage_data.size();
    //ステージデータが無い(=第1ウェーブ)の場合
    if (stage_data.empty()) {
        //templateファイルの生成
        //std::ofstream(RESOURCE_TABLE->GetFolderPath() + fileName);
        return false;
    }
    return true;
}

SceneBase * EditMap::PanelFunction()
{

    for (auto p : PANEL_MGR->_objects) {

        if (p == nullptr)
            continue;

        //
        bool isClicked = p->IsClicked();

        //何かのパネルがクリックされる。
        //そのパネルの種類(クラス)によって
        //処理内容が変化する。
        //また、別のサブクラスのパネルの変数に
        //干渉する

        //パネルがクリックされたら
        if (isClicked) {
            auto str = p->GetTypeName();

            //クリックされたパネルの名前が"AffectObjects"だった場合
            if (str.find("AffectObject") != NPOS) {
                PanelAffectObjectsFunction(p->GetCategoryName());
            }
            else if (str.find("Displayer") != NPOS) {
                PanelDisplayerFunction(*p);
            }
            else if (str.find("SceneTrans") != NPOS) {
                PanelSceneTransFunction(*p);
            }
            else if (str.find("SettingObject") != NPOS) {
                PanelSettingObjectFunction(*p);
            }

            p->Update();
        }
    }

    return this;
}

void EditMap::PanelAffectObjectsFunction(std::string category_name)
{
    std::vector<std::shared_ptr<PanelBase>> temp_p;

    using iterator = decltype(_allSettingPanel)::iterator;

    std::pair<iterator, iterator> obj = _allSettingPanel.equal_range(category_name);

    //auto obj = _allSettingPanel.find(category_name)->second;

    /*値を変化させる他パネルを検索する*/

#if 0
    for (auto p : ps) {
        if (p == nullptr)
            continue;

        auto class_name = p->GetTypeName();

        //カテゴリー名が一致したものをpに上書きする
        if (class_name.find("SettingObject") != NPOS) {
            //temp_p.push_back(*ps);
            //auto b = temp_p.back(); //テスト用
            /*
            if (obj != _allSettingPanel.end()) {
                p = std::move(obj);
                auto afetr = p;
            }
            */
            temp_p.push_back(p);
        }
    }
#endif

    int elem_num = 0;
    for (iterator it = obj.first; it != obj.second; ++it) {
        //temp_p[elem_num] = std::move(it->second);
        temp_p.push_back(it->second);
        auto t = temp_p.back();
        ++elem_num;
    }

    auto s = temp_p.size();
    auto temp_itr = temp_p.begin();

    auto& ps = PANEL_MGR->_objects;

    for (auto& p : ps) {
        if (p == nullptr)
            continue;

        size_t dis1 = std::distance(temp_p.begin(), temp_itr);


        if (dis1 >= temp_p.size())
            break;
            
        auto class_name = p->GetPanelClassName();

        //クラス名が一致したものをpに上書きする
        if (class_name.find("SettingObject") != NPOS) {
            //auto te = std::move(temp_itr);
            p = *temp_itr;
           // p = std::make_shared<PanelBase>(temp_itr);
//            p = std::move(std::make_shared<PanelBase>(temp_itr));
            ++temp_itr;
        }
    }

    PANEL_MGR->Refresh();

    temp_p.shrink_to_fit();
}

void EditMap::PanelDisplayerFunction(PanelBase& panel)
{
}

void EditMap::PanelSceneTransFunction(PanelBase& panel)
{
}

void EditMap::PanelSettingObjectFunction(PanelBase& panel)
{
}

void EditMap::SetPanelInstance(std::string key_name, std::shared_ptr<PanelBase>& panel, PanelContent& temp)
{
    if (key_name == "CHANGE_LIST") {
        panel = std::make_shared<PanelAffectObjects>(temp);
    }
    else if (key_name == "MOVE") {
        panel = std::make_shared<PanelSceneTransition>(temp);
    }
    else if (key_name == "SELECT_OBJ") {
        panel = std::make_shared<PanelSettingObject>(temp);
        /*NOTE:ここにBlock,Monster,Trapのいずれかの要素を入れる処理を差し込む*/
        /*NOTE:現在コンストラクタにある画像読み込み処理を上記の処理後に入れる*/
        //_allSettingPanel.push_back(std::make_shared<PanelSettingObject>(temp));
    }
    else if (key_name == "SHOW") {
        panel = std::make_shared<PanelDisplayer>(temp);
    }
}

void EditMap::DebugOutputFile()
{
    std::ofstream writing_file;
    writing_file.open(RESOURCE_TABLE->GetFolderPath() + "test.csv", std::ios::out);
    writing_file.close();
}